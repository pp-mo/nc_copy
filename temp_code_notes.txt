
Group.resolve_all_refs(self, create_missing=True, create_at_top=False)
    """
    Scan for all element references within this group and its children, and
    replace these with links to actual definitions found in any of the parent
    groups of the reference.

    This can create new definitions anywhere in the hierarchy that this group
    belongs to, including in its parents.

    Kwargs:

    * create_missing (bool):
        Whether to create matching attached definitions, when existing ones are
        not present in the existing group structure.
        If False, the unresolved references are left as detached elements (but
        these may be copies of the originals).
    * create_at_top (bool):
        Whether to place any created missing definitions in the root group.
        If False, missing definitions are made in the smallest enclosing
        group.
        With create_at_top=False, multiple independent but identical
        definitions may be created.
        With create_at_top=True, conflicts are possible and errors may result.

        .. note::
 
           When 'create_missing' is False, this key has no effect.

    """

#
# NOTE: this is pretty dangerous (!)
# Maybe need a safe public-facing wrapper, that requires call on the root.
#

Group.copy(self, create_missing=False, create_at_top=False):
    """
    Create a new copy of the group, preserving internal element references
    as far as possible, but decoupled from the existing one.

    If the group contains references to elements with no definitions in the
    group hierarchy, or in the parents of this group, these will either be left
    unresolved, or linked to newly created definitions, as instructed.

    Kwargs:

    * create_missing (bool):
        Behaviour as for 'resolve_all_refs'.  If False, the result can contain
        unresolved references.
    * create_at_top (bool):
        Behaviour as for 'resolve_all_refs' (can raise an error).

    """
    # Replicate this group, but NB replica has no parent groups.
    group = self.detached_copy()
    # Resolve refs (internal ones will come out as they were).
    group.resolve_all_refs(create_missing=create_missing,
                           create_at_top=create_at_top)
    return group



MORE To-dos:
============

NcObj rename to NcElement ?
    NetCDF datamodel description call these 'components'
    --but the word is not repeated ??
    https://www.unidata.ucar.edu/software/netcdf/docs/data_model.html

Variables data access:
    Should reflect direct indexing to the NetCDF4 underlying, allows getting
        data from variable (see 'usecase_code_ideas.txt')

Group structure tracking:
    needs add/remove hooks to NcGroupsContainer (see latest ncobj.__init__)

File i/o compatibility and "resolution":
    on file output, in addition to references resolution
        *also* need to check that variable data dimensionality matches the
        numbers in the related dimension objects

Usecase examples:
    needs an example using Groups structures, e.g. copying whole Groups
    demo copy-then-remove-bits, as opposed to copy-selected-bits ?
    demo to point out automatic re-creation of dimensions etc when copying
    demo to point out *problems* of automatic dimension creation/matching ??
